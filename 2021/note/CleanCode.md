# Clean Code

### 깨끗한 코드
- 대충 짠 프로그램이 돌아간다는 안도감, 나중에 정리하겠다는 다짐으로 쓰레기 코드를 나눈다면? 르블랑의 법칙, 나중은 결코 오지 않는다.
- 나쁜 코드가 쌓일 수록 팀 생산성은 떨어진다.
- 촉박한 일정, 요구사항의 변경으로 나쁜 코드가 만들어지는 걸까? 태도: 프로그래머는 좋은 코드를 사수해야하는 책임이 있다.
- 나쁜 코드의 위험을 이해하지 못하는 관리자 말을 따르는 행동은 전문가답지 못하다.
- 언제나 코드를 최대한 깨끗하게 유지하는 습관
- 깨끗한 코드란
  - 우하하고 효율적인 코드, 보기 즐거운 코드
  - 한가지에 집중하는 코드
  - 잘 쓴 문장 처럼 읽히는 코드, 가독성
  - 다른 사람이 고치기 쉬운 코드
  - 주의 깊게 작성한 코드, 세세한 사항까지 신경 쓴 코드
  - 모든 테스트를 통과한다, 중복이 없다, 시스템 내 모든 설계 아이디어를 표현한다, 클래스 메서드 함수 등을 최대한 줄인다.
- 보이스카우트 규칙: 캠프장은 처음 왔을 떄보다 더 깨끗하게 해놓고 떠나라
  - 시간이 지나도 깨끗하게 유지하는 코드

### 의미있는 이름
- 의도를 분명히 밝혀라
  - 주석이 필요하다면 의도가 드러나지 않는 이름이다.
  - 함축성 이름보다는, 정보를 제공하는 이름을 만든다.
- 그릇된 정보를 피해라
  - No: 약어, 특수한 의미가 있는 단어 ex) List, 일관성이 떨어지는 표기법
- 의미 있게 구분하라
  - No: 연속 적인 숫자를 덧붙인 이름 ex) a1, a2, 불용어를 추가한 이름 ex) NamingString, CustomerObject
  - 읽는 사람이 차이를 알도록 이름을 지어야한다.
- 발음하기 쉬운 이름을 사용하라
- 검색하기 쉬운 이름을 사용하라
  - 숫자를 사용한 것과 숫자를 상수를 선언하는 것을 생각해보자, 상수로 선언한 것을 찾기 더 쉽다.
- 클래스 이름: 명사, 명사구
  - Good: Customer, WikiPage, Account, AddressParser
  - Worst: Manager, Processor, Data, Info 같은 단어, 동사
- 메서드 이름: 동사, 동사구
  - Good: postPayment, deletePage, save
- 기발한 이름은 피하라
- 한 개념에 한 단어를 사용하라
  - 클래스마다 fetch, retrieve, get을 혼용해서 쓰는 것은 안좋다.
  - 일관성 있는 어휘 사용
- 말장난을 하지마라
  - 한 단어를 두가지 목적으로 사용하지 않는다.
  - 같은 맥락에서만 동일한 단어를 사용한다.
- 해법 영역에서 가져온 이름을 사용하라
  - 기술 개념에서 기 술 이름은 적합한 선택이다.
  - 전산 용어, 알고리즘 이름, 패턴 이름, 수학 용어 등을 사용해도 괜찮다.
- 문제 영역에서 가져온 이름을 사용하라
  - 적절한 '프로그래머 용어'가 없을 때, 문제 영역 이름을 사용한다.
- 의미 있는 맥락을 추가하라
  - 맥락이 불분명하다면 클래스를 만들어서 변수를 넣으면, 변수의 맥락이 분명해질 수 있다.
- 불필요한 맥락을 없애라
  - 의미가 분명한 경우에 불필요한 맥락을 추가하지 않는다.

### 함수
- 부수 효과를 일으키지 마라
  - checkPassword를 호출했을 때, 세션을 초기화하는 부수 효과가 숨겨져있다면?
  - 함수 이름을 분명히 명시하는 것이 좋다. ex) checkPasswordAndInitializeSession
````
boolean checkPassword() {
  if (valid) {
    session.initialize()
  }
}
````

### 주석
- 나쁜 코드에 주석을 달지마라, 새로 짜라
- 코드의 의도를 표현하지 못할 때 주석을 사용한다.
- 좋은 주석
  - 법적인 주석, 저작권 정보, 소유권 정보
  - 정보를 제공하는 주석
  - 의미를 명료하게 밝히는 주석, 인수나 반환 값이 표준 라이브러리나 변경하지 못하는 코드에 속한다면
  - TODO 주석

### 형식 맞추기
- 신문 기사처럼 작성하라
  - 이름은 간단하고 설명이 가능하게
  - 소스 파일 첫 부분은 고차원 개념, 알고리즘 설명
  - 아래로 내려갈 수록 의도를 세세하게 묘사
- 개념은 빈 행으로 분리하라
  - 빈 행은 새로운 개념을 시작한다는 시각적 단서
- 세로 밀집도
  - 세로 밀집도는 연관성을 의미한다. 서로 밀접한 코드 행은 세로 가까이 놓여야 한다.
- 개념적 유사성
  - 친화도가 높은 코드는 가까이 배치한다.
  - 한 함수에서 다른 함수를 호출하는 직접적 종속성
  - 비슷한 동작을 수행하는 일군 함수

### 객체와 자료 구조
- 디미터 법칙: 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다.
````
class A {
    private B b;
    public setA(B b) {
        b = b;
    }
    public myMethod(OtherObject other) {
        // ...
    }
    // 디미터 법칙
    public valid(Paramemter param) {
        myMethod(); // 자신의 메소드
        b.method(); // 자신의 멤버의 메소드
        Local local = new Local();
        local.method(); // 직접 생성한 객체의 메소드 
        param.method(); // 인수로 넘어온 객체 메소드
    }
    // 위반
    public invalid(Paramemter param) {
        C c = param.getC();
        c.method(); // 인자로 받은 객체에서 호출
        param.getC().method();
    }
}
````
- 객체는 자료를 숨기고 함수를 공개한다.
- 자료구조는 함수 없이 자료를 노출한다.
- 새로운 자료 타입을 추가하는 유연성이 필요하면: 객체
- 새로운 동작을 추가하는 유연성이 필요하면: 자료 구조

### 단위 테스트
- TDD 법칙 세 가지
  - 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
  - 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
  - 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.
- 깨끗한 테스트 코드 유지하기
  - 테스트 코드는 사고와 설계와 주의가 필요하다. 실제 코드만큼 깨끗하게 짜야 한다.
  - 테스트는 유연성, 유지보수성, 재사용성을 제공한다.
  - 테스트 케이스가 업사면 모든 변경이 잠정적 버그이다.
  - 가독성은 실제 코드보다 테스트 코드에서 더 중요하다.
  - 명료성, 단순성, 풍부한 표현력, 최소의 표현으로 많은 것을 나타내야 한다.
  - 실제 코드만큼 효율적일 필요는 없다.
- 테스트 당 assert 하나
  - assert 문이 하나인 함수는 결론이 하나라서 코드를 이해하기 쉽고 빠르다.
  - 테스트를 분리하면 중복된 코드가 많아질 수 있다. @Before 함수를 사용하거나 Template method 패턴을 사용하여 중복을 줄여줄 수도 있다.
  - 하지만 배보다 배꼽이 더 커지는 모습이기도하다.
  - 단일 assert 문이 좋은 지침이지만, 상황에 따라 여러개를 써도 괜찮다. 단지 assert문 개수를 최대한 줄이는 것이 좋다.
- 테스트 당 개념 하나
  - 독자적인 개념은 독자적인 테스트로 만드는 것이 좋다.
- F.I.R.S.T
  - First: 빠르게, 테스트는 빨라야 한다. 느리면 자주 돌리지 못하고, 초반에 문제를 찾아 고치기 어렵다.
  - Independent: 독립적으로, 각 테스트는 서로 의존하면 안 된다. 테스트는 독립적으로 어떤 순서로 실행되도 괜찮아야한다.
  - Repeatable: 반복가능하게, 어떤 환경에서도 반복 가능해야한다.
  - Self-Validating: 자가검증하는, 테스트는 부울값으로 결과를 내야 한다. 성공 아니면 실패다. 테스트 스스로가 성공 실패를 가늠하지 않는다면 판단은 주관적이 되며, 수작업 평가가 필요하다.
  - Timely: 적시에, 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다. 그렇지 않다면, 테스트가 불가능하도록 실제 코드를 설계할지도 모른다.

### 클래스
- 클래스 이름은 해당 클래스 책임을 기술해야 한다.
- 클래스 이름이 모호하다면 클래스 책임이 많아서다. Processor, Manager, Super 모호한 단어들
- 단일 책임 원칙 SRP: 클래스나 모듈을 변경할 이규가 하나여야 한다. 
- 응집도: 클래스는 인스턴스 변수 수가 작아야 한다. 메서드가 변수를 많이 사용할수록 메서드와 클래스 응집도가 높아진다.
  - 응집도가 높아지면 변수와 메서드를 적절히 분리해 새로운 클래스로 쪼갠다.

### 창발성
- 단순한 설계 규칙
- 모든 테스트를 실행하라
  - 설계는 의도한 대로 돌아가는 시스템을 내놓아야 한다.
  - 결합도가 높으면 테스트 케이스를 작성하기 어렵다.
  - 테스트 케이스를 만들고 계속 돌려라, 간단하고 단순한 규칙을 따르면 시스템은 낮은 결합도와 높은 응집도를 가진다.
- 리팩터링
  - 코드를 추가할 때마다 잠시 멈추고 설계를 조감한다.
- 중복을 없애라
  - 소규모 재사용을 익히면, 대규모 재사용도 가능하다.
- 표현하라
  - 자신이 이해하는 코드를 짜기는 쉽다. 하지만 나중에 코드를 유지보수할 사람이 코드를 짜는 사람만큼 문제를 깊이 이해할 가능성은 희박하다.
  - 좋은 이름을 선택한다.
  - 함수와 클래스 크기를 줄인다.
  - 표준 명칭을 사용한다.
  - 단위 테스트 케이스를 꼼꼼히 작성한다. 테스트 케이스는 예제로 보여주는 문서다.
  - 조금 더 주위를 기울이자, 주의는 재능이다.

### 동시성
- 동시성 방어 원칙
  - 단일 책임 원칙: 동시성 코든느 다른 코드와 분리하라
  - 따름 정리: 자료 범위를 제한하라, 자료를 캡슐화하라. 공유 자료를 최대한 줄여라
  - 따름 정리: 자료 사본을 사용하라
  - 따름 정리: 스레드는 가능한 독립적으로 구현하라
- 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라
- 다중 스레드 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라

### 냄새와 휴리스틱
- 최소 놀람의 원칙 The Principle of Least Surprise
  - 함수나 클래스는 다른 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야 한다.
  - 신뢰하지 못하는 코드는 전체를 살펴보게 한다.
- 중복을 발견할 때마다 추상화할 기회로 간주하라
- 추상화는 저차원 상세 개념에서 고차원 일반 개념을 분리한다.
  - 세부 구현과 관련한 상수, 변수, 유틸리티 함수는 기초 클래스에 넣으면 안된다.
  ````
  public interface Stack {
    Object pop() throws EmptyException;
    void push(Object o) throws FullException;
    double percentFull();
    class EmptyException extends Exception { }
    class FullException extends Exception { }
  }
  ````
  - percentFull 함수는 추상화 수준이 바르지 않다. 어떤 구현은 꽉 찬 정도라는 개념이 타당하지만, 어떤 구현은 알 방법이 없다.
  - 그러므로 함수는 BoundedStack 같은 파생 인터페이스에 어울린다.
 - 재정의할 가능성이 있다면 static 함수보다 인스턴스 함수가 더 좋다.
 - 이름과 기능을 일치시킨다.
   - 5일을 더하는 함수인지, 5주를 더하는지, 5시간을 더하는지 알 수 없다.
   - 5일을 더해서 date 인스턴스를 변경하는 함수라면 addDaysTo 또는 increaseByDays
   - date 인스턴스는 변경하지 않으면서 5일 뒤인 새 날짜를 반환한다면 daysLater 또는 daysSince
    ````
    Date newDate = date.add(5);
    ````
- 숨겨진 시간적인 결합
  ````
  // Worst
  public class MoogDiver {
    Gradient gradient;
    List<Spline> splines;

    public void dive(String reason) {
      saturateGradient();
      reticulateSplines();
      diveForMoog(reason);
    }
   }

   // Good
   public class MoogDiver {
    Gradient gradient;
    List<Spline> splines;

    public void dive(String reason) {
      Gradient gradient = saturateGradient();
      List<Spline> splines = reticulateSplines(gradient);
      diveForMoog(splines, reason);
    }
   }
  ````
  - 세 함수가 실행되는 순서가 중요하다면, 일종의 연결 소자를 생성하여 시간적 결합을 노출한다. 함수가 복잡해지더라고 의도적으로 추가한 구문적인 복잡성이 원래 있던 시간적인 복잡성을 드러낸 것이다.