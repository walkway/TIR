# 오브젝트

### 객체, 설계

- 두 객체 사이의 결합도가 높으면 높을수록 함께 변경될 확률이 높아지기 때문에 변경하기 어려워진다. 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만들어야 한다.
- 객체 내부의 상태를 캡슐화하고 객체 간에 메시지를 통해서 상호작용하도록 만든다.
- 연관 작업만 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도가 높다고 한다.
- 책임의 이동, 집중되어있는 것을 개별 객체로 이동시킨다. 따라서 각 객체는 자신을 스스로 책임진다.
- 좋은 설계는 오늘 완성해야하는 기능을 구현하는 코드를 짜야하는 동시에 내일 쉽게 변경할 수 있는 코드를 짜야한다. 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계다.

### 객체지향 프로그래밍

- 객체는 상태와 행동을 함께 가지는 복합적인 존재다. 객체는 스스로 판단하고 행동하는 자율적인 존재다.
- 코드 재사용: 상속, 합성
- 상속의 안좋은 영향은 캡슐화를 위반하고, 설계를 유연하지 못하게 만든다.
  - 부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화된다. 캡슐화의 약화는 자식 클래스가 부모 클래스에 강하게 결합되도록 만들기 때문에 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 확률을 높인다. 결과적으로 상속을 많이 사용하느 코드는 변경이 어렵다.
  - 상속은 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정한다. 따라서 실행 시점에 객체의 종류 변경이 불가능 하다.
- 합성은 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법이다.

### 역할, 책임, 협력

- 협력이란 어떤 객체가 다른 객체에게 무엇인가를 요청하는 것이다. 객체 사이의 협력을 설계할 때는 객체를 서로 분리된 인스턴스가 아닌 협력하는 파트너로 인식해야 한다.
- 자율적인 객체는 자신에게 할당된 책임을 수행하던 중에 필요한 정보를 알지 못하거나 외부의 도움이 필요한 경우 적절한 객체에게 메시지를 전송해서 협력을 요청한다.
- 협력이 설계를 위한 문맥을 결정한다.
- 책임은 객체에 의해 정의되는 응집도 있는 행위의 집합으로 객체가 유지해야 하는 정보와 수행할 수 있는 행동에 대해 개략적으로 서술한 문장이다.
- 책임은 객체가 무엇을 알고 있는가, 무엇을 할 수 있는가로 구성된다.
- 메시지가 객체를 결정한다.
  - 객체가 최소한의 인터페이스를 가질 수 있게된다.
  - 추상적인 인터페이스를 가질 수 있게 된다.

### 설계 품질과 트레이드 오프
- 캡슐화는 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법이다. 변경될 수 있는 어떤 것이라도 캡슐화해야 한다.
- 응집도는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다. 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도를 측정할 수 있다.
- 결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도다.
- 좋은 설계란 높은 응집도와 낮은 결합도를 가진 모듈로 구성되어야 한다.
- 단일 책임 원칙, 클래스는 한 가지 변경 이유만 가져야 한다.

### 책임 할당하기
- GRASP 일반적인 책임 할당을 위한 소프트웨어 패턴
- 애플리케이션이 제공해야 하는 기능을 애플리케이션의 책임으로 생각해라
  - 메시지를 전송할 객체는 무엇을 원하는가?
  - 메시지를 수신할 적합한 객체는 누구인가?
- information expert 정보 전문가 패턴
  - 책임을 수행하는 데 필요한 정보를 가지고 있는 객체에게 할당하라
  - 정보와 행동을 최대한 가까운 곳에 위치시키기 때문에 캡슐화를 유지할 수 있다.
  - 책임을 수행하는 객체가 정보를 알고 있다고 해서 그 정보를 저장하고 있을 필요는 없다.
- low coupling 패턴
  - 설계의 전체적인 결합도가 낮게 유지되도록 책임을 할당하라
- high cohesion 패턴
  - 높은 응집도를 유지할 수 있게 책임을 할당하라
- creator 패턴
  - 어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것이다.
- 클래스 응집도 판단
  - 클래스가 하나 이상의 이유로 변경돼야 한다면 응집도가 낮은 것이다. 변경 이유를 기준으로 클래스를 분리하라
  - 클래스의 인스턴스를 초기화하는 시점에 경우에 따라 서로 다른 속성들을 초기화하고 있다면 응집도가 낮은 것이다. 초기화되는 속성의 그룹을 기준으로 클래스를 분리하라
  - 메서드 그룹이 속성 그룹을 사용하느닞 여부로 나뉜다면 응집도가 낮은 것이다. 이들 그룹을 기준으로 클래스를 분리하라
- polymorphism 패턴
  - 타입을 명시적으로 정의하고 각 타입에 다형적으로 행동하는 책임을 할당하라
- protected variations 패턴
  - 변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당하라
- 몬스터 메서드, 이해하기 어렵고 응집도가 낮은 메서드
  - 메서드의 이름과 메서드 몸체의 의미적 차이의 중요성

### 메시지와 인터페이스
- 메시지: 객체가 다른 객체와 협력하기 위해 사용하는 의사소통 메커니즘
- 오퍼레이션: 객체가 다른 객체에게 제공하는 추상적인 서비스
- 메서드: 메시지에 응답하기 위해 실행되는 코드 블록
- 퍼블릭 인터페이스: 객체가 협력에 참여하기 위해 외부에서 수신할 수 있는 메시지 묶음
- 시그니처: 오퍼레이션이나 메서드의 명세
- 디미터의 법칙: 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로 제한
  - this 객체
  - 메서드의 매개변수
  - this의 속성
  - this의 속성인 컬렉션 요소
  - 메서드 내에서 생성된 지역 객체
- Tell, Don't Ask 스타일
- 의도를 나타내는 인터페이스

### 객체 분해
- 모듈은 서브 프로그램이라기보다는 책임의 할당이다. 모듈화는 개별적인 모듈에 대한 작업이 시작되기 전에 정해져야 하는 설계 결정들을 포함한다.
- 정보 은닉은 외부에 감춰야 하는 비밀에 따라 시스템을 분할하는 모듈 분할 원리이다.
  - 복잡성: 모듈이 너무 복잡한 경우 이해하고 사용하기 어렵다. 외부에 모듈을 추상화 할 수 있는 간단한 인터페이스를 제공해서 모듈 복잡도를 낮춘다.
  - 변경 가능성: 변경 가능한 설계 결정이 외부에 노출될 경우 실제로 변경이 발생했을 때 파급효과가 커진다. 변경 발생 시 하나의 모듈만 수정하면 되도록 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공한다.
- 추상 데이터 타입
  - 타입 정의를 선언할 수 있어야 한다.
  - 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다.
  - 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다.
  - 타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다.
- 추상 데이터 타입은 타입을 추상화한 것이고, 클래스는 절차를 추상화한 것이다.

### 의존성 관리하기
- 의존성은 두 요소 사이의 관계 유무를 설명한다. 의존성의 관점에서 "의존성이 존재한다" 또는 "의존성이 존재하지 않는다"라고 표현해야 한다.
- 결합도는 두 요소 사이에 존재하는 의존성의 정도를 상대적으로 표현한다. 결합도의 관점에서는 "결합도가 강하다" 또는 "결합도가 느슨하다"라고 표현한다.
- 의존성은 명시적으로 표현되어야 한다. 유연하고 재사용 가능한 설계란 퍼블릭 인터페이스를 통해 의존성이 명시적으로 드러나는 설계다.
- new 연산자를 사용하기 위해서는 구체 클래스 이름을 직접 기술해야한다. new를 사용하는 클라이언트는 추상화가 아닌 구체 클래스에 의존할 수 밖에 없기 때문에 결합도가 높아진다.

### 유연한 설계
- 개방 폐쇠 원칙: 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 열려 있어야 하고, 수정에 닫혀 있어야 한다.
- 객체에 대한 생성과 사용을 분리해야한다.
- 의존성 역전 원칙
  - 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다.
  - 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.

### 상속과 코드 재사용
- DRY 원칙
  - Don't Repeat Yourself
  - 모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을 만한 표현 양식을 가져야 한다.
- 자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다. super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.
- 상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.
- 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.
- 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수밖에 없다.