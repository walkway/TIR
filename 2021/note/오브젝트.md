# 오브젝트

### 객체, 설계

- 두 객체 사이의 결합도가 높으면 높을수록 함께 변경될 확률이 높아지기 때문에 변경하기 어려워진다. 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만들어야 한다.
- 객체 내부의 상태를 캡슐화하고 객체 간에 메시지를 통해서 상호작용하도록 만든다.
- 연관 작업만 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도가 높다고 한다.
- 책임의 이동, 집중되어있는 것을 개별 객체로 이동시킨다. 따라서 각 객체는 자신을 스스로 책임진다.
- 좋은 설계는 오늘 완성해야하는 기능을 구현하는 코드를 짜야하는 동시에 내일 쉽게 변경할 수 있는 코드를 짜야한다. 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계다.

### 객체지향 프로그래밍

- 객체는 상태와 행동을 함께 가지는 복합적인 존재다. 객체는 스스로 판단하고 행동하는 자율적인 존재다.
- 코드 재사용: 상속, 합성
- 상속의 안좋은 영향은 캡슐화를 위반하고, 설계를 유연하지 못하게 만든다.
  - 부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화된다. 캡슐화의 약화는 자식 클래스가 부모 클래스에 강하게 결합되도록 만들기 때문에 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 확률을 높인다. 결과적으로 상속을 많이 사용하느 코드는 변경이 어렵다.
  - 상속은 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정한다. 따라서 실행 시점에 객체의 종류 변경이 불가능 하다.
- 합성은 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법이다.

### 역할, 책임, 협려

- 협력이란 어떤 객체가 다른 객체에게 무엇인가를 요청하는 것이다. 객체 사이의 협력을 설계할 때는 객체를 서로 분리된 인스턴스가 아닌 협력하는 파트너로 인식해야 한다.
- 자율적인 객체는 자신에게 할당된 책임을 수행하던 중에 필요한 정보를 알지 못하거나 외부의 도움이 필요한 경우 적절한 객체에게 메시지를 전송해서 협력을 요청한다.
- 협력이 설계를 위한 문맥을 결정한다.
- 책임은 객체에 의해 정의되는 응집도 있는 행위의 집합으로 객체가 유지해야 하는 정보와 수행할 수 있는 행동에 대해 개략적으로 서술한 문장이다.
- 책임은 객체가 무엇을 알고 있는가, 무엇을 할 수 있는가로 구성된다.
- 메시지가 객체를 결정한다.
  - 객체가 최소한의 인터페이스를 가질 수 있게된다.
  - 추상적인 인터페이스를 가질 수 있게 된다.

### 설계 품질과 트레이드 오프
- 캡슐화는 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법이다. 변경될 수 있는 어떤 것이라도 캡슐화해야 한다.
- 응집도는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다. 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도를 측정할 수 있다.
- 결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도다.
- 좋은 설계란 높은 응집도와 낮은 결합도를 가진 모듈로 구성되어야 한다.
- 단일 책임 원칙, 클래스는 한 가지 변경 이유만 가져야 한다.