# 오브젝트

### 객체, 설계

- 두 객체 사이의 결합도가 높으면 높을수록 함께 변경될 확률이 높아지기 때문에 변경하기 어려워진다. 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만들어야 한다.
- 객체 내부의 상태를 캡슐화하고 객체 간에 메시지를 통해서 상호작용하도록 만든다.
- 연관 작업만 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도가 높다고 한다.
- 책임의 이동, 집중되어있는 것을 개별 객체로 이동시킨다. 따라서 각 객체는 자신을 스스로 책임진다.
- 좋은 설계는 오늘 완성해야하는 기능을 구현하는 코드를 짜야하는 동시에 내일 쉽게 변경할 수 있는 코드를 짜야한다. 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계다.

### 객체지향 프로그래밍

- 객체는 상태와 행동을 함께 가지는 복합적인 존재다. 객체는 스스로 판단하고 행동하는 자율적인 존재다.
- 코드 재사용: 상속, 합성
- 상속의 안좋은 영향은 캡슐화를 위반하고, 설계를 유연하지 못하게 만든다.
  - 부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화된다. 캡슐화의 약화는 자식 클래스가 부모 클래스에 강하게 결합되도록 만들기 때문에 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 확률을 높인다. 결과적으로 상속을 많이 사용하느 코드는 변경이 어렵다.
  - 상속은 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정한다. 따라서 실행 시점에 객체의 종류 변경이 불가능 하다.
- 합성은 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법이다.